\documentclass{article}

\title{Trabajo Practico 1}
\author{De Rosa - Schapira - Guerrero}
\date{Primer Cuatrimestre 2017}

\begin{document}
    \pagenumbering{gobble}
    \maketitle
    \newpage
    \pagenumbering{roman}
    \tableofcontents
    \newpage
    \pagenumbering{arabic}

    \section{Asignacion de residencias}
        \subsection{Objetivo}
            Solucionar el problema de la asignacion de residencias utilizando
            el algoritmo de Gale-Shapley de Matching Estable.
        \subsection{Conclusiones}
            \subsubsection{Complejidad del algoritmo}
                Si bien el ciclo principal del algoritmo (sin tener en cuenta 
                llamadas a funciones internas dentro de él) tiene un orden de complejidad 
                $O(nk)$, donde k es la cantidad maxima de vacantes de cada hospital, 
                el algoritmo tiene un orden de complejidad $O(n^2)$. Esto se da por la 
                creacion de la matriz de preferencias, pues es necesario al calcularla analizar 
                la posicion de cada estudiante en la lista que contiene a cada uno de los hospitales.
            \subsubsection{Tiempo de ejecucion}
                Si se hacen pruebas con cantidades de estudiantes ($n$) y de hospitales
                ($m$) iguales se obtienen los siguientes resultados:
                %Tabla de resultados
                \begin{table}[h!]
                    \centering
                    \caption{Tiempo de resolucion del problema}
                    \begin{tabular}{c|c|c}
                        n & m & t \\
                        \hline
                        10 & 10 & 0.6ms \\
                        \hline
                        100 & 100 & 30ms \\
                        \hline
                        500 & 500 & 2.5s \\
                        \hline
                        1000 & 1000 & 19.1s \\
                        \hline
                        3000 & 3000 & 8m 34s
                    \end{tabular}
                \end{table}

                Como se puede ver, estos tiempos representan valores mucho menores a
                los esperados por un algoritmo $O(n^2)$. Consideramos que esto es
                resultado de la forma en que se crea la anteriormente mencionada
                matriz de preferencias. Suponemos que la implementacion de los
                diccionarios por comprension de Python permiten un rendimiento mucho
                mejor que $O(n^2)$.
            \subsubsection{Reduccion del problema de los casamientos}
                El algoritmo implementado permite resolver el problema de matching
                estable cuando el grupo de \emph{reviewers} puede aceptar a mas de
                un \emph{aplicante}. Por lo tanto, si consideraramos que cada reviewer
                puede aceptar solo a \underline{un} aplicante, tenemos el problema
                de la formacion de parejas. Por lo tanto, vemos que ese problema
                puede ser reducido al ya resuelto si la lista Q de vacantes es tal
                que $Q = [1]*n$.

    \section{Puntos de Falla}
        \subsection{Objetivo}
            Encontrar los puntos de fallas (puntos de articulacion) de una red eléctrica
            mediante el algoritmo de Hopcroft y Tarjan.
        \subsection{Conclusiones}
            \subsubsection{Funcionamiento del algoritmo}
                El algoritmo comienza tomando un vertice cualquiera del grafo, a partir
                del cual se realiza un recorrido dfs. Este genera un grafo del recorrido
                iniciado en el vertice elegido. En este grafo, sera punto de articulacion
                cada vertice que tenga dos o mas conocidos, es decir que tenga dos o mas
                hijos. Luego para cada vertice en el grafo de recorrido dfs, chequeamos
                la cantidad de vecinos que tiene. Si se cumple la condición, entonces es un punto
                de articulacion. Por lo tanto el orden del algoritmo sera $O(v+e)$.

            \subsubsection{Tiempo de ejecucion}
                Haciendo la prueba con una cantidad $(v)$ de vertices obtenemos lo siguiente:
                %Tabla de resultados
                \begin{table}[h!]
                    \centering
                    \caption{Tiempo de resolucion del problema}
                    \begin{tabular}{c|c}
                        v & t \\
                        \hline
                        10 & 0.25 ms \\
                        \hline
                        100 & 1.8 ms \\
                        \hline
                        1000 & 9.5 ms \\
                        \hline
                        10000 & 0.093 s \\
                        \hline
                        100000 & 0.99 s \\
                        \hline
                        1000000 & 10.34 s
                    \end{tabular}
                \end{table}

                Como se puede observar, los tiempos aumentan linealmente a medida
                que aumenta la cantidad de vertices. Esto condice con los tiempos
                esperados del algoritmo.


    \section{Comunidades en Redes}
        \subsection{Objetivo}
          Encontrar las componentes fuertemente conexas de las comunidades en las
          redes implementando el algoritmo de kosaraju.
        \subsection{Conclusiones}
            \subsubsection{Funcionamiento del algoritmo}
                El algoritmo comienza realizando un recorrido dfs de cada uno de los
                vertices. Esto se realiza para ordenar los vertices en sentido
                decreciente de acuerdo a su tiempo de finalizacion entre todos los
                recorridos dfs. Una vez que se obtiene el orden de los vertices,
                se invierte el grafo, es decir que se invierten todas sus aristas.
                El tiempo que toma invertir el grafo es $O(v+e)$. Luego se vuelve a
                realizar un recorrido dfs para cada vertice iniciando por el vertice
                que tiene mayor tiempo de finalizacion. Cada grafo que devuelto por cada
                recorrido dfs es una componente fuertemente conexa.
                El orden del algoritmo sera $O(v+e)$

            \subsubsection{Tiempo de ejecucion}
              Haciendo la prueba con una cantidad v de vertices y a de aristas obtenemos:
              %Tabla de resultados
                \begin{table}[h!]
                    \centering
                    \caption{Tiempo de resolucion del problema}
                    \begin{tabular}{c|c|c}
                        v & a & t \\
                        \hline
                        10 & 20 & 0.00084 s \\
                        \hline
                        100 & 250 & 0.048 s \\
                        \hline
                        1000 & 2500 & 3.008 s \\
                        \hline
                        10000 & 25000 & 322.01 s
                    \end{tabular}
                \end{table}

                Como podemos observar, los tiempos de resolucion aumentan en medida
                cuadratica. Esto no concuerda con la prediccion esperada, la cual es
                lineal. Atribuimos esto a la eficiencia de la computadora en la que
                se hicieron las pruebas.

\end{document}
