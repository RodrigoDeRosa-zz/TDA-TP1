\documentclass{article}
\usepackage[utf8]{inputenc}

\title{Trabajo Practico 1}
\author{De Rosa - Schapira - Guerrero}
\date{Primer Cuatrimestre 2017}

\begin{document}
    \pagenumbering{gobble}
    \maketitle
    \newpage
    \pagenumbering{roman}
    \tableofcontents
    \newpage
    \pagenumbering{arabic}

    \section{Asignacion de residencias}
        \subsection{Objetivo}
            Solucionar el problema de la asignación de residencias utilizando
            el algoritmo de Gale-Shapley de Matching Estable.
        \subsection{Conclusiones}
            \subsubsection{Complejidad del algoritmo}
                Si bien el ciclo principal del algoritmo (sin tener en cuenta
                llamadas a funciones internas dentro de él) tiene un orden de complejidad
                $O(nk)$, donde k es la cantidad máxima de vacantes de cada hospital,
                el algoritmo tiene un orden de complejidad $O(n^2)$. Esto se da por la
                creación de la matriz de preferencias, pues es necesario al calcularla analizar
                la posición de cada estudiante en la lista que contiene a cada uno de los hospitales.
            \subsubsection{Tiempo de ejecucion}
                Si se hacen pruebas con cantidades de estudiantes ($n$) y de hospitales
                ($m$) iguales se obtienen los siguientes resultados:
                %Tabla de resultados
                \begin{table}[h!]
                    \centering
                    \caption{Tiempo de resolución del problema}
                    \begin{tabular}{c|c|c}
                        n & m & t \\
                        \hline
                        10 & 10 & 0.6ms \\
                        \hline
                        100 & 100 & 30ms \\
                        \hline
                        500 & 500 & 2.5s \\
                        \hline
                        1000 & 1000 & 19.1s \\
                        \hline
                        3000 & 3000 & 8m 34s
                    \end{tabular}
                \end{table}

                Como se puede ver, estos tiempos representan valores mucho menores a
                los esperados por un algoritmo $O(n^2)$. Consideramos que esto es
                resultado de la forma en que se crea la anteriormente mencionada
                matriz de preferencias. Suponemos que la implementación de los
                diccionarios por comprensión de Python permiten un rendimiento mucho
                mejor que $O(n^2)$.
            \subsubsection{Reduccion del problema de los casamientos}
                El algoritmo implementado permite resolver el problema de matching
                estable cuando el grupo de \emph{reviewers} puede aceptar a más de
                un \emph{aplicante}. Por lo tanto, si consideráramos que cada reviewer
                puede aceptar solo a \underline{un} aplicante, tenemos el problema
                de la formación de parejas. Entonces, vemos que ese problema
                puede ser reducido al ya resuelto si la lista Q de vacantes es tal
                que $Q = [1]*n$.

    \section{Puntos de Falla}
        \subsection{Objetivo}
            Encontrar los puntos de fallas (puntos de articulación) de una red eléctrica
            mediante el algoritmo de Hopcroft y Tarjan.
        \subsection{Conclusiones}
            \subsubsection{Funcionamiento del algoritmo}
                El algoritmo comienza tomando un vértice cualquiera del grafo, a partir
                del cual se realiza un recorrido dfs y se numeran los vertices en el orden
                en que fueron visitados, lo cual llamamos distancia de descubrimiento.
                Luego mediante otro recorrido dfs, enumeramos para todos los hijos el menor
                tiempo de descubrimiento, teniendo en cuenta el del padre, a esto lo denominamos
                lowpoint. Por ultimo realizamos un recorrido para obtener los puntos de articulacion
                del grafo teniendo en cuenta 2 condiciones. La primera es que si un nodo es raiz
                y tiene mas de 2 hijos, es punto de articulacion. La segunda condicion es:
                low [ hijo ] >= distancia [ padre ].
                Por lo tanto el orden del algoritmo será $O(v+e)$, ya que lo unico que se hace
                son recorridos dfs en instancias separadas.

            \subsubsection{Tiempo de ejecucion}
                Haciendo la prueba con una cantidad $(v)$ de vértices obtenemos lo siguiente:
                %Tabla de resultados
                \begin{table}[h!]
                    \centering
                    \caption{Tiempo de resolución del problema}
                    \begin{tabular}{c|c}
                        v & t \\
                        \hline
                        10 & 0.53 ms \\
                        \hline
                        100 & 4.52 ms \\
                        \hline
                        1000 & 22.74 ms \\
                        \hline
                        10000 & 0.24 s \\
                        \hline
                        100000 & 5.87 s \\
                        \hline
                        1000000 & 22,39 m
                    \end{tabular}
                \end{table}

                Como se puede observar, los tiempos aumentan linealmente a medida
                que aumenta la cantidad de vértices hasta la anteultima prueba.
                Esto condice con los tiempos esperados del algoritmo. La ultima prueba
                tiene un salto temporal, que lo atribuimos a las desventajas que nos
                pudo haber generado realizarlo iterativo en vez de recursivo. Sin
                embargo, la version iterativa nos permite probar 1000000 de vertices,
                cuando la recursiva no lo soporta.


    \section{Comunidades en Redes}
        \subsection{Objetivo}
          Encontrar las componentes fuertemente conexas de las comunidades en las
          redes implementando el algoritmo de kosaraju.
        \subsection{Conclusiones}
            \subsubsection{Funcionamiento del algoritmo}
                El algoritmo comienza realizando un recorrido dfs de cada uno de los
                vértices. Esto se realiza para ordenar los vértices en sentido
                decreciente de acuerdo a su tiempo de finalización entre todos los
                recorridos dfs. Una vez que se obtiene el orden de los vértices,
                se invierte el grafo, es decir que se invierten todas sus aristas.
                El tiempo que toma invertir el grafo es $O(v+e)$. Luego se vuelve a
                realizar un recorrido dfs para cada vértice iniciando por el vértice
                que tiene mayor tiempo de finalización. Cada grafo que devuelto por cada
                recorrido dfs es una componente fuertemente conexa.
                El orden del algoritmo será $O(v+e)$

            \subsubsection{Tiempo de ejecucion}
              Haciendo la prueba con una cantidad v de vértices y a de arístas obtenemos:
              %Tabla de resultados
                \begin{table}[h!]
                    \centering
                    \caption{Tiempo de resolución del problema}
                    \begin{tabular}{c|c|c}
                        v & a & t \\
                        \hline
                        10 & 20 & 0.00084 s \\
                        \hline
                        100 & 250 & 0.048 s \\
                        \hline
                        1000 & 2500 & 3.008 s \\
                        \hline
                        10000 & 25000 & 322.01 s
                    \end{tabular}
                \end{table}

                Como podemos observar, los tiempos de resolución aumentan en medida
                cuadrática. Esto no concuerda con la predicción esperada, la cuál es
                lineal. Atribuimos esto a la eficiencia de la computadora en la que
                se hicieron las pruebas.

    \section{Comandos}
      python matchingEstable.py \\
      python puntosDeArticulacion.py \\
      python componentesConexas.py

\end{document}
